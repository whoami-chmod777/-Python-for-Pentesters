
• Python allows for user defined exceptions
• Code up a demo which has a user defined exception and an example use case

-- Exception Handling --

Exceptions in Python are errors that occur during program execution, disrupting the normal flow of the program. They are handled using try, except, else, and finally blocks to prevent the program from crashing and to allow graceful error handling.


>>> 0/0
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ZeroDivisionError: division by zero
>>> 
>>> 
>>> try:
...     a = 0/0
... except:
...     print("Exception Happend")
... 
Exception Happend
>>> 
>>> 
>>> try:
...     a = 10/20
... except:
...     print("Exception")
... else:
...     print("No Exception")
... finally:
...     print("Cleanup Code")
... 
No Exception
Cleanup Code
>>> 
>>>
>>> try:
...     a = 0/0
... except ZeroDivisionError:
...     print("Divide by Zero")
... except:
...     print("Unknown error")
... 
Divide by Zero
>>> 
>>> 
>>> try:
...     a = 0/0
... except Exception as im:
...     print(im)
... 
division by zero


-- Example --

try:
    x = 10 / 0  # This will raise a ZeroDivisionError
except ZeroDivisionError:
    print("Cannot divide by zero!")


Here's a simple example of creating a custom exception and using it in a program:

# Define a custom exception class
class CustomError(Exception):
    def __init__(self, message):
        super().__init__(message)

# Example use case
def divide(a, b):
    if b == 0:
        raise CustomError("Division by zero is not allowed")
    return a / b

try:
    result = divide(10, 2)
    print("Result:", result)
    
    result = divide(5, 0)  # This will raise a CustomError
    print("Result:", result)  # This line won't be executed

except CustomError as e:
    print("CustomError:", e)
except ZeroDivisionError as e:
    print("ZeroDivisionError:", e)
except Exception as e:
    print("Exception:", e)



In this example, we've defined a custom exception class called 'CustomError'. This class inherits from the built-in 'Exception' class and has an '__init__' method to set a custom error message.
The 'divide' function checks if the denominator ('b') is zero and raises a 'CustomError' with a specific message if it is. We then demonstrate using this custom exception in a try-except block. When we call 'divide(10, 2)', it works correctly, but when we call 'divide(5, 0)', it raises a 'CustomError', which we catch and print the error message.
Custom exceptions are useful for creating meaningful and specific error handling in your code.

#!/usr/bin/python
# This sample code is part of the SecurityTube Python Scripting Expert course and certification
# Website : http://securitytube-training.com
# Author: Vivek Ramachandran

# simple script to check for Disallow in robots.txt 

# simple custom exception to throw if a Disallow is found 

class DisallowPresent(Exception) :

	def __init__(self, path) :
		self.disallowed_path = path

	def __str__(self) :
		return repr(self.disallowed_path) 

import urllib2

secTube = urllib2.urlopen('http://www.bbc.co.uk/robots.txt')

for line in secTube.readlines():
    try :
	if line.lower().find('disallow') != -1 :
		print line.strip()
		raise DisallowPresent(line.split(':')[1].strip())

    except DisallowPresent as ex :
		print "Exception occured for path : " +ex.disallowed_path




